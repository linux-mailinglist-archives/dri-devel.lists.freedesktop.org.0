Return-Path: <dri-devel-bounces@lists.freedesktop.org>
X-Original-To: lists+dri-devel@lfdr.de
Delivered-To: lists+dri-devel@lfdr.de
Received: from gabe.freedesktop.org (gabe.freedesktop.org [IPv6:2610:10:20:722:a800:ff:fe36:1795])
	by mail.lfdr.de (Postfix) with ESMTPS id E8AB1608487
	for <lists+dri-devel@lfdr.de>; Sat, 22 Oct 2022 07:26:52 +0200 (CEST)
Received: from gabe.freedesktop.org (localhost [127.0.0.1])
	by gabe.freedesktop.org (Postfix) with ESMTP id C42F510E302;
	Sat, 22 Oct 2022 05:26:37 +0000 (UTC)
X-Original-To: dri-devel@lists.freedesktop.org
Delivered-To: dri-devel@lists.freedesktop.org
Received: from mga17.intel.com (mga17.intel.com [192.55.52.151])
 by gabe.freedesktop.org (Postfix) with ESMTPS id A7EDA10E302;
 Sat, 22 Oct 2022 05:26:32 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
 d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
 t=1666416392; x=1697952392;
 h=date:message-id:from:to:cc:subject:in-reply-to:
 references:mime-version;
 bh=aCR3qhv8aZ8pRL0dRbWD4NRWFomZph93McTQZxXdTME=;
 b=FcnlPRI3rTfa6JAh3MmhkVnuVeXSxqjp2FvV3Wd6PsauGVPfNHkciYKF
 eSCbKnJrPklsq6abCYUM67L3yaHOwqPtCaUc5SbKbBQfsMzj2BIyIjKHi
 pVJxQpm4FWs6Z3oVR2CBJIZLan4oc4rxDWPtMvAd8+GeuwiaGSEhaxY9B
 QSj4bH+Oj+I2L8vHxFMHit11GXMePWj+GswsCK0uncOI57/XqS59HHbYl
 RFczQoFXK7FGlJeYC08gevJbqtIALlV9oGj9+KnbLAN+O76YazWymnswz
 AOYkram48LxEVBM57tsrhqyJ4Z7KL5W0Yv1Vp7ScVWagZVhGOFXl6Rp/G Q==;
X-IronPort-AV: E=McAfee;i="6500,9779,10507"; a="287556263"
X-IronPort-AV: E=Sophos;i="5.95,204,1661842800"; d="scan'208";a="287556263"
Received: from orsmga006.jf.intel.com ([10.7.209.51])
 by fmsmga107.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 21 Oct 2022 22:26:31 -0700
X-IronPort-AV: E=McAfee;i="6500,9779,10507"; a="608628591"
X-IronPort-AV: E=Sophos;i="5.95,204,1661842800"; d="scan'208";a="608628591"
Received: from adixit-mobl.amr.corp.intel.com (HELO adixit-arch.intel.com)
 ([10.255.230.194])
 by orsmga006-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 21 Oct 2022 22:26:31 -0700
Date: Fri, 21 Oct 2022 22:26:30 -0700
Message-ID: <87v8ocpgxl.wl-ashutosh.dixit@intel.com>
From: "Dixit, Ashutosh" <ashutosh.dixit@intel.com>
To: "Belgaumkar, Vinay" <vinay.belgaumkar@intel.com>
Subject: Re: [Intel-gfx] [PATCH v3] drm/i915/slpc: Use platform limits for
 min/max frequency
In-Reply-To: <30cc2c72-38f6-7d30-91f0-709b55b472fd@intel.com>
References: <20221018183031.33704-1-vinay.belgaumkar@intel.com>	<8735biqf22.wl-ashutosh.dixit@intel.com>	<30cc2c72-38f6-7d30-91f0-709b55b472fd@intel.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?ISO-8859-4?Q?Goj=F2?=) APEL-LB/10.8 EasyPG/1.0.0
 Emacs/28.2 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-BeenThere: dri-devel@lists.freedesktop.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: Direct Rendering Infrastructure - Development
 <dri-devel.lists.freedesktop.org>
List-Unsubscribe: <https://lists.freedesktop.org/mailman/options/dri-devel>,
 <mailto:dri-devel-request@lists.freedesktop.org?subject=unsubscribe>
List-Archive: <https://lists.freedesktop.org/archives/dri-devel>
List-Post: <mailto:dri-devel@lists.freedesktop.org>
List-Help: <mailto:dri-devel-request@lists.freedesktop.org?subject=help>
List-Subscribe: <https://lists.freedesktop.org/mailman/listinfo/dri-devel>,
 <mailto:dri-devel-request@lists.freedesktop.org?subject=subscribe>
Cc: intel-gfx@lists.freedesktop.org, Riana Tauro <riana.tauro@intel.com>,
 dri-devel@lists.freedesktop.org
Errors-To: dri-devel-bounces@lists.freedesktop.org
Sender: "dri-devel" <dri-devel-bounces@lists.freedesktop.org>

On Fri, 21 Oct 2022 18:38:57 -0700, Belgaumkar, Vinay wrote:
> On 10/20/2022 3:57 PM, Dixit, Ashutosh wrote:
> > On Tue, 18 Oct 2022 11:30:31 -0700, Vinay Belgaumkar wrote:
> > Hi Vinay,
> >
> >> diff --git a/drivers/gpu/drm/i915/gt/selftest_slpc.c b/drivers/gpu/drm/i915/gt/selftest_slpc.c
> >> index 4c6e9257e593..e42bc215e54d 100644
> >> --- a/drivers/gpu/drm/i915/gt/selftest_slpc.c
> >> +++ b/drivers/gpu/drm/i915/gt/selftest_slpc.c
> >> @@ -234,6 +234,7 @@ static int run_test(struct intel_gt *gt, int test_type)
> >>	enum intel_engine_id id;
> >>	struct igt_spinner spin;
> >>	u32 slpc_min_freq, slpc_max_freq;
> >> +	u32 saved_min_freq;
> >>	int err = 0;
> >>
> >>	if (!intel_uc_uses_guc_slpc(&gt->uc))
> >> @@ -252,20 +253,35 @@ static int run_test(struct intel_gt *gt, int test_type)
> >>		return -EIO;
> >>	}
> >>
> >> -	/*
> >> -	 * FIXME: With efficient frequency enabled, GuC can request
> >> -	 * frequencies higher than the SLPC max. While this is fixed
> >> -	 * in GuC, we level set these tests with RPn as min.
> >> -	 */
> >> -	err = slpc_set_min_freq(slpc, slpc->min_freq);
> >> -	if (err)
> >> -		return err;
> >> +	if (slpc_min_freq == slpc_max_freq) {
> >> +		/* Server parts will have min/max clamped to RP0 */
> >> +		if (slpc->min_is_rpmax) {
> >> +			err = slpc_set_min_freq(slpc, slpc->min_freq);
> >> +			if (err) {
> >> +				pr_err("Unable to update min freq on server part");
> >> +				return err;
> >> +			}
> >>
> >> -	if (slpc->min_freq == slpc->rp0_freq) {
> >> -		pr_err("Min/Max are fused to the same value\n");
> >> -		return -EINVAL;
> >> +		} else {
> >> +			pr_err("Min/Max are fused to the same value\n");
> >> +			return -EINVAL;
> > Sorry but I am not following this else case here. Why are we saying min/max
> > are fused to the same value? In this case we can't do
> > "slpc_set_min_freq(slpc, slpc->min_freq)" ? That is, we can't change SLPC
> > min freq?
>
> This would be an error case due to a faulty part. We may come across a part
> where min/max is fused to the same value.

But even then the original check is much clearer since it is actually
comparing the fused freq's:

	if (slpc->min_freq == slpc->rp0_freq)

Because if min/max have been changed slpc_min_freq and slpc_max_freq are no
longer fused freq.

And also this check should be right at the top of run_test, right after if
(!intel_uc_uses_guc_slpc), rather than in the middle here (otherwise
because we are basically not doing any error rewinding so causing memory
leaks if any of the functions return error).

> >>+		}
> >>+	} else {
> >>+		/*
> >>+		 * FIXME: With efficient frequency enabled, GuC can request
> >>+		 * frequencies higher than the SLPC max. While this is fixed
> >>+		 * in GuC, we level set these tests with RPn as min.
> >>+		 */
> >>+		err = slpc_set_min_freq(slpc, slpc->min_freq);
> >>+		if (err)
> >>+			return err;
> >> 	}

So let's do what is suggested above and then see what remains here and if
we need all these code changes. Most likely we can just do unconditionally
what we were doing before, i.e.:

	err = slpc_set_min_freq(slpc, slpc->min_freq);
	if (err)
		return err;

> >>
> >>+	saved_min_freq = slpc_min_freq;
> >>+
> >>+	/* New temp min freq = RPn */
> >>+	slpc_min_freq = slpc->min_freq;

Why do we need saved_min_freq? We can retain slpc_min_freq and in the check below:

	if (max_act_freq <= slpc_min_freq)

We can just change the check to:

	if (max_act_freq <= slpc->min_freq)

Looks like to have been a bug in the original code?

> >>+
> >> 	intel_gt_pm_wait_for_idle(gt);
> >> 	intel_gt_pm_get(gt);
> >> 	for_each_engine(engine, gt, id) {
> >>@@ -347,7 +363,7 @@ static int run_test(struct intel_gt *gt, int test_type)
> >>
> >> 	/* Restore min/max frequencies */
> >> 	slpc_set_max_freq(slpc, slpc_max_freq);
> >>-	slpc_set_min_freq(slpc, slpc_min_freq);
> >>+	slpc_set_min_freq(slpc, saved_min_freq);
> >>
> >> 	if (igt_flush_test(gt->i915))
> >> 		err = -EIO;
> >
> >> diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c b/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c
> >> index fdd895f73f9f..b7cdeec44bd3 100644
> >> --- a/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c
> >> +++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c
> >> @@ -263,6 +263,7 @@ int intel_guc_slpc_init(struct intel_guc_slpc *slpc)
> >>
> >>	slpc->max_freq_softlimit = 0;
> >>	slpc->min_freq_softlimit = 0;
> >> +	slpc->min_is_rpmax = false;
> >>
> >>	slpc->boost_freq = 0;
> >>	atomic_set(&slpc->num_waiters, 0);
> >> @@ -588,6 +589,32 @@ static int slpc_set_softlimits(struct intel_guc_slpc *slpc)
> >>	return 0;
> >>   }
> >>
> >> +static bool is_slpc_min_freq_rpmax(struct intel_guc_slpc *slpc)
> >> +{
> >> +	int slpc_min_freq;
> >> +
> >> +	if (intel_guc_slpc_get_min_freq(slpc, &slpc_min_freq))
> >> +		return false;
> > I am wondering what happens if the above fails on server? Should we return
> > true or false on server and what are the consequences of returning false on
> > server?
> >
> > Any case I think we should at least put a drm_err or something here just in
> > case this ever fails so we'll know something weird happened.
>
> Makes sense.
>
> >> +
> >> +	if (slpc_min_freq == SLPC_MAX_FREQ_MHZ)
> >> +		return true;
> >> +	else
> >> +		return false;
> >> +}
> >> +
> >> +static void update_server_min_softlimit(struct intel_guc_slpc *slpc)
> >> +{
> >> +	/* For server parts, SLPC min will be at RPMax.
> >> +	 * Use min softlimit to clamp it to RP0 instead.
> >> +	 */
> >> +	if (is_slpc_min_freq_rpmax(slpc) &&
> >> +	    !slpc->min_freq_softlimit) {

This should be swapped around:

	if (!slpc->min_freq_softlimit && is_slpc_min_freq_rpmax(slpc))

So we should only have to call is_slpc_min_freq_rpmax if
slpc->min_freq_softlimit is 0 (that is only once the first time during
init).

> >> +		slpc->min_is_rpmax = true;
> >> +		slpc->min_freq_softlimit = slpc->rp0_freq;
> >> +		(slpc_to_gt(slpc))->defaults.min_freq = slpc->min_freq_softlimit;
> >> +	}
> >> +}
> >> +
> >>   static int slpc_use_fused_rp0(struct intel_guc_slpc *slpc)
> >>   {
> >>	/* Force SLPC to used platform rp0 */
> >> @@ -647,6 +674,9 @@ int intel_guc_slpc_enable(struct intel_guc_slpc *slpc)
> >>
> >>	slpc_get_rp_values(slpc);
> >>
> >> +	/* Handle the case where min=max=RPmax */
> >> +	update_server_min_softlimit(slpc);
> >> +
> >>	/* Set SLPC max limit to RP0 */
> >>	ret = slpc_use_fused_rp0(slpc);
> >>	if (unlikely(ret)) {
> >> diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.h b/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.h
> >> index 82a98f78f96c..11975a31c9d0 100644
> >> --- a/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.h
> >> +++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.h
> >> @@ -9,6 +9,8 @@
> >>   #include "intel_guc_submission.h"
> >>   #include "intel_guc_slpc_types.h"
> >>
> >> +#define SLPC_MAX_FREQ_MHZ 4250
> >
> > This seems to be really a value (255 converted to freq) so seems ok to
> > intepret in MHz.
> >
> > Thanks.
> > --
> > Ashutosh
