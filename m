Return-Path: <dri-devel-bounces@lists.freedesktop.org>
X-Original-To: lists+dri-devel@lfdr.de
Delivered-To: lists+dri-devel@lfdr.de
Received: from gabe.freedesktop.org (gabe.freedesktop.org [IPv6:2610:10:20:722:a800:ff:fe36:1795])
	by mail.lfdr.de (Postfix) with ESMTPS id E13EA606C19
	for <lists+dri-devel@lfdr.de>; Fri, 21 Oct 2022 01:37:34 +0200 (CEST)
Received: from gabe.freedesktop.org (localhost [127.0.0.1])
	by gabe.freedesktop.org (Postfix) with ESMTP id 89EC010E40A;
	Thu, 20 Oct 2022 23:37:16 +0000 (UTC)
X-Original-To: dri-devel@lists.freedesktop.org
Delivered-To: dri-devel@lists.freedesktop.org
Received: from mga04.intel.com (mga04.intel.com [192.55.52.120])
 by gabe.freedesktop.org (Postfix) with ESMTPS id A74CE10E072;
 Thu, 20 Oct 2022 23:37:09 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
 d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
 t=1666309029; x=1697845029;
 h=date:message-id:from:to:cc:subject:in-reply-to:
 references:mime-version;
 bh=rGkfV65+/rqWtBGh4VO5+FmYzIszg0EwiRsmIvIKul8=;
 b=chvmRGVn3CR9boDpeP7BpV/Hbf29wUlnefcSPXbE29EybWet5h8Y3ywu
 giqDkwILFxLND3Ru66TH5Vg3HC/I6D8tTh3IgJg3vGHVi3xMYfZP/D8ZF
 IU80OrfQYHe+Ton5KB9zcpnYebW0dXxCWT/a07mxmS/ShwGSi7T2ilTqq
 rtsjLTg9QHTg+puT4bznpKUfIsujUpdr2DEQp0eAsHRcbicCCs4fGB1rR
 9d7ae7XI1cUMzYkYp1jC7ZLjjYc3VQuNx+IQMVqmqape3p+6JG4VBL/21
 6Sm4nt3QBX8/vha54R2fCbE+lw8yd8OTSYDGNgFQIaNb9zBgfFqrW4t2e A==;
X-IronPort-AV: E=McAfee;i="6500,9779,10506"; a="305600186"
X-IronPort-AV: E=Sophos;i="5.95,200,1661842800"; d="scan'208";a="305600186"
Received: from fmsmga007.fm.intel.com ([10.253.24.52])
 by fmsmga104.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 20 Oct 2022 16:36:50 -0700
X-IronPort-AV: E=McAfee;i="6500,9779,10506"; a="632562551"
X-IronPort-AV: E=Sophos;i="5.95,200,1661842800"; d="scan'208";a="632562551"
Received: from adixit-mobl.amr.corp.intel.com (HELO adixit-arch.intel.com)
 ([10.212.153.148])
 by fmsmga007-auth.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 20 Oct 2022 16:36:50 -0700
Date: Thu, 20 Oct 2022 16:36:49 -0700
Message-ID: <871qr2qd7y.wl-ashutosh.dixit@intel.com>
From: "Dixit, Ashutosh" <ashutosh.dixit@intel.com>
To: "Belgaumkar, Vinay" <vinay.belgaumkar@intel.com>
Subject: Re: [Intel-gfx] [PATCH v3] drm/i915/slpc: Optmize waitboost for SLPC
In-Reply-To: <bbe2b4c5-04be-bdc3-3911-d1544516eac1@intel.com>
References: <20221020002944.4228-1-vinay.belgaumkar@intel.com>	<874jvyqr9o.wl-ashutosh.dixit@intel.com>	<bbe2b4c5-04be-bdc3-3911-d1544516eac1@intel.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?ISO-8859-4?Q?Goj=F2?=) APEL-LB/10.8 EasyPG/1.0.0
 Emacs/28.2 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-BeenThere: dri-devel@lists.freedesktop.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: Direct Rendering Infrastructure - Development
 <dri-devel.lists.freedesktop.org>
List-Unsubscribe: <https://lists.freedesktop.org/mailman/options/dri-devel>,
 <mailto:dri-devel-request@lists.freedesktop.org?subject=unsubscribe>
List-Archive: <https://lists.freedesktop.org/archives/dri-devel>
List-Post: <mailto:dri-devel@lists.freedesktop.org>
List-Help: <mailto:dri-devel-request@lists.freedesktop.org?subject=help>
List-Subscribe: <https://lists.freedesktop.org/mailman/listinfo/dri-devel>,
 <mailto:dri-devel-request@lists.freedesktop.org?subject=subscribe>
Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>,
 intel-gfx@lists.freedesktop.org, dri-devel@lists.freedesktop.org
Errors-To: dri-devel-bounces@lists.freedesktop.org
Sender: "dri-devel" <dri-devel-bounces@lists.freedesktop.org>

On Thu, 20 Oct 2022 13:16:00 -0700, Belgaumkar, Vinay wrote:
>
> On 10/20/2022 11:33 AM, Dixit, Ashutosh wrote:
> > On Wed, 19 Oct 2022 17:29:44 -0700, Vinay Belgaumkar wrote:
> > Hi Vinay,
> >
> >> Waitboost (when SLPC is enabled) results in a H2G message. This can result
> >> in thousands of messages during a stress test and fill up an already full
> >> CTB. There is no need to request for RP0 if GuC is already requesting the
> >> same.
> > But how are we sure that the freq will remain at RP0 in the future (when
> > the waiting request or any requests which are ahead execute)?
> >
> > In the current waitboost implementation, set_param is sent to GuC ahead of
> > the waiting request to ensure that the freq would be max when this waiting
> > request executed on the GPU and the freq is kept at max till this request
> > retires (considering just one waiting request). How can we ensure this if
> > we don't send the waitboost set_param to GuC?
>
> There is no way to guarantee the frequency will remain at RP0 till the
> request retires. As a theoretical example, lets say the request boosted
> freq to RP0, but a user changed min freq using sysfs immediately after.

That would be a bug. If waitboost is in progress and in the middle user
changed min freq, I would expect the freq to revert to the new min only
after the waitboost phase was over.

In any case, I am not referring to this case. Since FW controls the freq
there is nothing preventing FW to change the freq unless we raise min to
max which is what waitboost does.

> Waitboost is done by a pending request to "hurry" the current requests. If
> GT is already at boost frequency, that purpose is served.

FW can bring the freq down later before the waiting request is scheduled.

> Also, host algorithm already has this optimization as well.

Host turbo is different from SLPC. Host turbo controls the freq algorithm
so it knows freq will not come down till it itself brings the freq
down. Unlike SLPC where FW is controling the freq. Therefore host turbo
doesn't ever need to do a MMIO read but only needs to refer to its own
state (rps->cur_freq etc.).

> >
> > I had assumed we'll do this optimization for server parts where min is
> > already RP0 in which case we can completely disable waitboost. But this
> > patch is something else.

Thanks.
--
Ashutosh

> >> v2: Add the tracing back, and check requested freq
> >> in the worker thread (Tvrtko)
> >> v3: Check requested freq in dec_waiters as well
> >>
> >> Signed-off-by: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
> >> ---
> >>   drivers/gpu/drm/i915/gt/intel_rps.c         |  3 +++
> >>   drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c | 14 +++++++++++---
> >>   2 files changed, 14 insertions(+), 3 deletions(-)
> >>
> >> diff --git a/drivers/gpu/drm/i915/gt/intel_rps.c b/drivers/gpu/drm/i915/gt/intel_rps.c
> >> index fc23c562d9b2..18b75cf08d1b 100644
> >> --- a/drivers/gpu/drm/i915/gt/intel_rps.c
> >> +++ b/drivers/gpu/drm/i915/gt/intel_rps.c
> >> @@ -1016,6 +1016,9 @@ void intel_rps_boost(struct i915_request *rq)
> >>		if (rps_uses_slpc(rps)) {
> >>			slpc = rps_to_slpc(rps);
> >>
> >> +			GT_TRACE(rps_to_gt(rps), "boost fence:%llx:%llx\n",
> >> +				 rq->fence.context, rq->fence.seqno);
> >> +
> >>			/* Return if old value is non zero */
> >>			if (!atomic_fetch_inc(&slpc->num_waiters))
> >>				schedule_work(&slpc->boost_work);
> >> diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c b/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c
> >> index b7cdeec44bd3..9dbdbab1515a 100644
> >> --- a/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c
> >> +++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_slpc.c
> >> @@ -227,14 +227,19 @@ static int slpc_force_min_freq(struct intel_guc_slpc *slpc, u32 freq)
> >>   static void slpc_boost_work(struct work_struct *work)
> >>   {
> >>	struct intel_guc_slpc *slpc = container_of(work, typeof(*slpc), boost_work);
> >> +	struct intel_rps *rps = &slpc_to_gt(slpc)->rps;
> >>	int err;
> >>
> >>	/*
> >>	 * Raise min freq to boost. It's possible that
> >>	 * this is greater than current max. But it will
> >>	 * certainly be limited by RP0. An error setting
> >> -	 * the min param is not fatal.
> >> +	 * the min param is not fatal. No need to boost
> >> +	 * if we are already requesting it.
> >>	 */
> >> +	if (intel_rps_get_requested_frequency(rps) == slpc->boost_freq)
> >> +		return;
> >> +
> >>	mutex_lock(&slpc->lock);
> >>	if (atomic_read(&slpc->num_waiters)) {
> >>		err = slpc_force_min_freq(slpc, slpc->boost_freq);
> >> @@ -728,6 +733,7 @@ int intel_guc_slpc_set_boost_freq(struct intel_guc_slpc *slpc, u32 val)
> >>
> >>   void intel_guc_slpc_dec_waiters(struct intel_guc_slpc *slpc)
> >>   {
> >> +	struct intel_rps *rps = &slpc_to_gt(slpc)->rps;
> >>	/*
> >>	 * Return min back to the softlimit.
> >>	 * This is called during request retire,
> >> @@ -735,8 +741,10 @@ void intel_guc_slpc_dec_waiters(struct intel_guc_slpc *slpc)
> >>	 * set_param fails.
> >>	 */
> >>	mutex_lock(&slpc->lock);
> >> -	if (atomic_dec_and_test(&slpc->num_waiters))
> >> -		slpc_force_min_freq(slpc, slpc->min_freq_softlimit);
> >> +	if (atomic_dec_and_test(&slpc->num_waiters)) {
> >> +		if (intel_rps_get_requested_frequency(rps) != slpc->min_freq_softlimit)
> >> +			slpc_force_min_freq(slpc, slpc->min_freq_softlimit);
> >> +	}
> >>	mutex_unlock(&slpc->lock);
> >>   }
> >>
> >> --
> >> 2.35.1
> >>
