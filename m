Return-Path: <dri-devel-bounces@lists.freedesktop.org>
X-Original-To: lists+dri-devel@lfdr.de
Delivered-To: lists+dri-devel@lfdr.de
Received: from gabe.freedesktop.org (gabe.freedesktop.org [131.252.210.177])
	by mail.lfdr.de (Postfix) with ESMTPS id 252FF55556D
	for <lists+dri-devel@lfdr.de>; Wed, 22 Jun 2022 22:32:58 +0200 (CEST)
Received: from gabe.freedesktop.org (localhost [127.0.0.1])
	by gabe.freedesktop.org (Postfix) with ESMTP id 07BB510F0B6;
	Wed, 22 Jun 2022 20:32:54 +0000 (UTC)
X-Original-To: dri-devel@lists.freedesktop.org
Delivered-To: dri-devel@lists.freedesktop.org
Received: from mga18.intel.com (mga18.intel.com [134.134.136.126])
 by gabe.freedesktop.org (Postfix) with ESMTPS id 7C1D110F124;
 Wed, 22 Jun 2022 20:32:52 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
 d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
 t=1655929972; x=1687465972;
 h=date:message-id:from:to:cc:subject:in-reply-to:
 references:mime-version;
 bh=Pbp28hVFIx4zw/QYe/kE5XEqw/BtBf2wVw0EU134mn4=;
 b=SunJD9Zm5HpyJmAcRpsz4KuwbZVO/eL4TxVaHBNU6Pin/ZXBe/r2w+9u
 YO0XLt441u0RPAbJXuOtTAQNazSGVIqgzUU2eefH5AJdEqMTj8wqbApjU
 PXRUdvlsmSyDTc5n9kP+GnmzsM03zjeAq6U1OMugmejW5IYYDYvo9ZLQZ
 Ia/FXLEjRRRtOQo/yGrImxbTJhfRuL4mVzbGbQz30owOK/Js/QwD56Fhv
 CQ7G8sQCD/iAa4w7QADRqDW0H4xxIWwHEkdJRFd6azEl8UNLrc3dfrY4C
 hyXAgS8O4PyCkO653nyCFVRwGD/k6qziCFsJn3BiXSLyov4Ji4KWy6bIQ A==;
X-IronPort-AV: E=McAfee;i="6400,9594,10386"; a="263572869"
X-IronPort-AV: E=Sophos;i="5.92,212,1650956400"; d="scan'208";a="263572869"
Received: from fmsmga004.fm.intel.com ([10.253.24.48])
 by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 22 Jun 2022 13:32:51 -0700
X-IronPort-AV: E=Sophos;i="5.92,212,1650956400"; d="scan'208";a="655844175"
Received: from adixit-mobl1.amr.corp.intel.com (HELO adixit-arch.intel.com)
 ([10.209.53.110])
 by fmsmga004-auth.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 22 Jun 2022 13:32:51 -0700
Date: Wed, 22 Jun 2022 13:32:51 -0700
Message-ID: <87leto1lsc.wl-ashutosh.dixit@intel.com>
From: "Dixit, Ashutosh" <ashutosh.dixit@intel.com>
To: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
Subject: Re: [Intel-gfx] [PATCH] drm/i915/guc/slpc: Add a new SLPC selftest
In-Reply-To: <20220610234712.36849-1-vinay.belgaumkar@intel.com>
References: <20220610234712.36849-1-vinay.belgaumkar@intel.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?ISO-8859-4?Q?Goj=F2?=) APEL-LB/10.8 EasyPG/1.0.0
 Emacs/28.1 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-BeenThere: dri-devel@lists.freedesktop.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: Direct Rendering Infrastructure - Development
 <dri-devel.lists.freedesktop.org>
List-Unsubscribe: <https://lists.freedesktop.org/mailman/options/dri-devel>,
 <mailto:dri-devel-request@lists.freedesktop.org?subject=unsubscribe>
List-Archive: <https://lists.freedesktop.org/archives/dri-devel>
List-Post: <mailto:dri-devel@lists.freedesktop.org>
List-Help: <mailto:dri-devel-request@lists.freedesktop.org?subject=help>
List-Subscribe: <https://lists.freedesktop.org/mailman/listinfo/dri-devel>,
 <mailto:dri-devel-request@lists.freedesktop.org?subject=subscribe>
Cc: intel-gfx@lists.freedesktop.org, dri-devel@lists.freedesktop.org
Errors-To: dri-devel-bounces@lists.freedesktop.org
Sender: "dri-devel" <dri-devel-bounces@lists.freedesktop.org>

On Fri, 10 Jun 2022 16:47:12 -0700, Vinay Belgaumkar wrote:
>
> This test will validate we can achieve actual frequency of RP0. Pcode
> grants frequencies based on what GuC is requesting. However, thermal
> throttling can limit what is being granted. Add a test to request for
> max, but don't fail the test if RP0 is not granted due to throttle
> reasons.
>
> Also optimize the selftest by using a common run_test function to avoid
> code duplication.

The refactoring does change the order of operations (changing the freq vs
spawning the spinner) but should be fine I think.

> Rename the "clamp" tests to vary_max_freq and vary_min_freq.

Either is ok, but maybe "clamp" names were ok I think since they verify req
freq is clamped at min/max.

>
> v2: Fix compile warning
>
> Fixes 8ee2c227822e ("drm/i915/guc/slpc: Add SLPC selftest")
> Signed-off-by: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
> ---
>  drivers/gpu/drm/i915/gt/selftest_slpc.c | 323 ++++++++++++------------
>  1 file changed, 158 insertions(+), 165 deletions(-)
>
> diff --git a/drivers/gpu/drm/i915/gt/selftest_slpc.c b/drivers/gpu/drm/i915/gt/selftest_slpc.c
> index b768cea5943d..099129aae9a5 100644
> --- a/drivers/gpu/drm/i915/gt/selftest_slpc.c
> +++ b/drivers/gpu/drm/i915/gt/selftest_slpc.c
> @@ -8,6 +8,11 @@
>  #define delay_for_h2g() usleep_range(H2G_DELAY, H2G_DELAY + 10000)
>  #define FREQUENCY_REQ_UNIT	DIV_ROUND_CLOSEST(GT_FREQUENCY_MULTIPLIER, \
>						  GEN9_FREQ_SCALER)
> +enum test_type {
> +	VARY_MIN,
> +	VARY_MAX,
> +	MAX_GRANTED
> +};
>
>  static int slpc_set_min_freq(struct intel_guc_slpc *slpc, u32 freq)
>  {
> @@ -36,147 +41,120 @@ static int slpc_set_max_freq(struct intel_guc_slpc *slpc, u32 freq)
>	return ret;
>  }
>
> -static int live_slpc_clamp_min(void *arg)
> +static int vary_max_freq(struct intel_guc_slpc *slpc, struct intel_rps *rps,
> +		  u32 *max_act_freq)

Please run checkpatch, indentation seems off.

>  {
> -	struct drm_i915_private *i915 = arg;
> -	struct intel_gt *gt = to_gt(i915);
> -	struct intel_guc_slpc *slpc = &gt->uc.guc.slpc;
> -	struct intel_rps *rps = &gt->rps;
> -	struct intel_engine_cs *engine;
> -	enum intel_engine_id id;
> -	struct igt_spinner spin;
> +	u32 step, max_freq, req_freq;
> +	u32 act_freq;
>	u32 slpc_min_freq, slpc_max_freq;
>	int err = 0;
>
> -	if (!intel_uc_uses_guc_slpc(&gt->uc))
> -		return 0;
> -
> -	if (igt_spinner_init(&spin, gt))
> -		return -ENOMEM;
> +	slpc_min_freq = slpc->min_freq;
> +	slpc_max_freq = slpc->rp0_freq;

nit but we don't really need such variables since we don't change their
values, we should just use slpc->min_freq, slpc->rp0_freq directly. I'd
change this in all places in this patch.

>
> -	if (intel_guc_slpc_get_max_freq(slpc, &slpc_max_freq)) {
> -		pr_err("Could not get SLPC max freq\n");
> -		return -EIO;
> -	}
> -
> -	if (intel_guc_slpc_get_min_freq(slpc, &slpc_min_freq)) {
> -		pr_err("Could not get SLPC min freq\n");
> -		return -EIO;

Why do we need these two function calls? Can't we just use slpc->rp0_freq
and slpc->min_freq as we are doing in the vary_min/max_freq() functions
above?

Also, as mentioned below I think here we should just do:

        slpc_set_max_freq(slpc, slpc->rp0_freq);
        slpc_set_min_freq(slpc, slpc->min_freq);

to restore freq to a known state before starting the test (just in case a
previous test changed the values).

> -	}
> -
> -	if (slpc_min_freq == slpc_max_freq) {
> -		pr_err("Min/Max are fused to the same value\n");
> -		return -EINVAL;

What if they are actually equal? I think basically the max/min freq test
loops will just not be entered (so effectively the tests will just
skip). The granted freq test will be fine. So I think we can just delete
this if statement?

(It is showing deleted above in the patch but is in the new code somewhere
too).

> -	}
> -
> -	intel_gt_pm_wait_for_idle(gt);
> -	intel_gt_pm_get(gt);
> -	for_each_engine(engine, gt, id) {
> -		struct i915_request *rq;
> -		u32 step, min_freq, req_freq;
> -		u32 act_freq, max_act_freq;
> -
> -		if (!intel_engine_can_store_dword(engine))
> -			continue;
> +	/* Go from max to min in 5 steps */
> +	step = (slpc_max_freq - slpc_min_freq) / NUM_STEPS;
> +	*max_act_freq = slpc_min_freq;
> +	for (max_freq = slpc_max_freq; max_freq > slpc_min_freq;
> +				max_freq -= step) {
> +		err = slpc_set_max_freq(slpc, max_freq);
> +		if (err)
> +			break;
>
> -		/* Go from min to max in 5 steps */
> -		step = (slpc_max_freq - slpc_min_freq) / NUM_STEPS;
> -		max_act_freq = slpc_min_freq;
> -		for (min_freq = slpc_min_freq; min_freq < slpc_max_freq;
> -					min_freq += step) {
> -			err = slpc_set_min_freq(slpc, min_freq);
> -			if (err)
> -				break;
> -
> -			st_engine_heartbeat_disable(engine);
> -
> -			rq = igt_spinner_create_request(&spin,
> -							engine->kernel_context,
> -							MI_NOOP);
> -			if (IS_ERR(rq)) {
> -				err = PTR_ERR(rq);
> -				st_engine_heartbeat_enable(engine);
> -				break;
> -			}
> +		req_freq = intel_rps_read_punit_req_frequency(rps);
>
> -			i915_request_add(rq);
> +		/* GuC requests freq in multiples of 50/3 MHz */
> +		if (req_freq > (max_freq + FREQUENCY_REQ_UNIT)) {
> +			pr_err("SWReq is %d, should be at most %d\n", req_freq,
> +				max_freq + FREQUENCY_REQ_UNIT);
> +			err = -EINVAL;

Probably a nit but check can be (so should we be checking both high and low
limits?):
		if (req_freq > (max_freq + FREQUENCY_REQ_UNIT) ||
		    req_freq < (slpc_min_freq - FREQUENCY_REQ_UNIT))

Though if we do this we'd need to change the pr_err() or have two separate
if statements. Not sure if it's worth it but thought I'll mention it.

> +static int vary_min_freq(struct intel_guc_slpc *slpc, struct intel_rps *rps,
> +		  u32 *max_act_freq)
> +{
> +	u32 step, min_freq, req_freq;
> +	u32 act_freq;
> +	u32 slpc_min_freq, slpc_max_freq;
> +	int err = 0;
>
> -			act_freq =  intel_rps_read_actual_frequency(rps);
> -			if (act_freq > max_act_freq)
> -				max_act_freq = act_freq;
> +	slpc_min_freq = slpc->min_freq;
> +	slpc_max_freq = slpc->rp0_freq;
>
> -			igt_spinner_end(&spin);
> -			st_engine_heartbeat_enable(engine);
> -		}
> +	/* Go from min to max in 5 steps */
> +	step = (slpc_max_freq - slpc_min_freq) / NUM_STEPS;
> +	*max_act_freq = slpc_min_freq;
> +	for (min_freq = slpc_min_freq; min_freq < slpc_max_freq;
> +				min_freq += step) {
> +		err = slpc_set_min_freq(slpc, min_freq);
> +		if (err)
> +			break;
>
> -		pr_info("Max actual frequency for %s was %d\n",
> -			engine->name, max_act_freq);
> +		req_freq = intel_rps_read_punit_req_frequency(rps);
>
> -		/* Actual frequency should rise above min */
> -		if (max_act_freq == slpc_min_freq) {

Nit again. This check is somewhere in the new code but I think a better
check is

		if (max_act_freq <= slpc_min_freq)

just in case the act freq for whatever reason falls below
slpc_min_freq. Even if we know this is impossible (bugs make the impossible
possible).

> -			pr_err("Actual freq did not rise above min\n");
> +		/* GuC requests freq in multiples of 50/3 MHz */
> +		if (req_freq < (min_freq - FREQUENCY_REQ_UNIT)) {
> +			pr_err("SWReq is %d, should be at least %d\n", req_freq,
> +				min_freq - FREQUENCY_REQ_UNIT);
>			err = -EINVAL;

Again nit as above, but check can be:
		if (req_freq < (min_freq - FREQUENCY_REQ_UNIT) ||
		    req_freq > (slpc_max_freq + FREQUENCY_REQ_UNIT)) {

>		}
>
> +		act_freq =  intel_rps_read_actual_frequency(rps);
> +		if (act_freq > *max_act_freq)
> +			*max_act_freq = act_freq;
> +
>		if (err)
>			break;
>	}
>
> -	/* Restore min/max frequencies */
> -	slpc_set_max_freq(slpc, slpc_max_freq);
> -	slpc_set_min_freq(slpc, slpc_min_freq);
> +	return err;
> +}
>
> -	if (igt_flush_test(gt->i915))
> -		err = -EIO;
> +static int max_granted_freq(struct intel_guc_slpc *slpc, struct intel_rps *rps, u32 *max_act_freq)
> +{
> +	struct intel_gt *gt = rps_to_gt(rps);
> +	u32 perf_limit_reasons;
> +	int err = 0;
>
> -	intel_gt_pm_put(gt);
> -	igt_spinner_fini(&spin);
> -	intel_gt_pm_wait_for_idle(gt);
> +	err = slpc_set_min_freq(slpc, slpc->rp0_freq);
> +	if (err)
> +		return err;
> +
> +	*max_act_freq =  intel_rps_read_actual_frequency(rps);
> +	if (!(*max_act_freq == slpc->rp0_freq)) {
> +		/* Check if there was some throttling by pcode */
> +		perf_limit_reasons = intel_uncore_read(gt->uncore, GT0_PERF_LIMIT_REASONS);
> +
> +		/* If not, this is an error */
> +		if (perf_limit_reasons && GT0_PERF_LIMIT_REASONS_MASK) {
> +			pr_err("Pcode did not grant max freq\n");
> +			err = -EINVAL;

Looks incorrect, probably something like:
		if (!(perf_limit_reasons & GT0_PERF_LIMIT_REASONS_MASK))

> +		}
> +	}
>
>	return err;
>  }
>
> -static int live_slpc_clamp_max(void *arg)
> +static int run_test(struct intel_gt *gt, int test_type)
>  {
> -	struct drm_i915_private *i915 = arg;
> -	struct intel_gt *gt = to_gt(i915);
> -	struct intel_guc_slpc *slpc;
> -	struct intel_rps *rps;
> +	struct intel_guc_slpc *slpc = &gt->uc.guc.slpc;
> +	struct intel_rps *rps = &gt->rps;
>	struct intel_engine_cs *engine;
>	enum intel_engine_id id;
>	struct igt_spinner spin;
> -	int err = 0;
>	u32 slpc_min_freq, slpc_max_freq;
> -
> -	slpc = &gt->uc.guc.slpc;
> -	rps = &gt->rps;
> +	int err = 0;
>
>	if (!intel_uc_uses_guc_slpc(&gt->uc))
>		return 0;
> @@ -203,69 +181,56 @@ static int live_slpc_clamp_max(void *arg)
>	intel_gt_pm_get(gt);
>	for_each_engine(engine, gt, id) {
>		struct i915_request *rq;
> -		u32 max_freq, req_freq;
> -		u32 act_freq, max_act_freq;
> -		u32 step;
> +		u32 max_act_freq;
>
>		if (!intel_engine_can_store_dword(engine))
>			continue;
>
> -		/* Go from max to min in 5 steps */
> -		step = (slpc_max_freq - slpc_min_freq) / NUM_STEPS;
> -		max_act_freq = slpc_min_freq;
> -		for (max_freq = slpc_max_freq; max_freq > slpc_min_freq;
> -					max_freq -= step) {
> -			err = slpc_set_max_freq(slpc, max_freq);
> -			if (err)
> -				break;
> -
> -			st_engine_heartbeat_disable(engine);
> -
> -			rq = igt_spinner_create_request(&spin,
> -							engine->kernel_context,
> -							MI_NOOP);
> -			if (IS_ERR(rq)) {
> -				st_engine_heartbeat_enable(engine);
> -				err = PTR_ERR(rq);
> -				break;
> -			}
> +		st_engine_heartbeat_disable(engine);
>
> -			i915_request_add(rq);
> +		rq = igt_spinner_create_request(&spin,
> +						engine->kernel_context,
> +						MI_NOOP);
> +		if (IS_ERR(rq)) {
> +			err = PTR_ERR(rq);
> +			st_engine_heartbeat_enable(engine);
> +			break;
> +		}
>
> -			if (!igt_wait_for_spinner(&spin, rq)) {
> -				pr_err("%s: SLPC spinner did not start\n",
> -				       engine->name);
> -				igt_spinner_end(&spin);
> -				st_engine_heartbeat_enable(engine);
> -				intel_gt_set_wedged(engine->gt);
> -				err = -EIO;
> -				break;
> -			}
> +		i915_request_add(rq);
> +
> +		if (!igt_wait_for_spinner(&spin, rq)) {
> +			pr_err("%s: Spinner did not start\n",
> +			       engine->name);
> +			igt_spinner_end(&spin);
> +			st_engine_heartbeat_enable(engine);
> +			intel_gt_set_wedged(engine->gt);
> +			err = -EIO;
> +			break;
> +		}
>
> -			delay_for_h2g();
> +		switch (test_type) {
>
> -			/* Verify that SWREQ indeed was set to specific value */
> -			req_freq = intel_rps_read_punit_req_frequency(rps);
> +		case VARY_MIN:
> +			err = vary_min_freq(slpc, rps, &max_act_freq);
> +			break;
> +
> +		case VARY_MAX:
> +			err = vary_max_freq(slpc, rps, &max_act_freq);
> +			break;
>
> -			/* GuC requests freq in multiples of 50/3 MHz */
> -			if (req_freq > (max_freq + FREQUENCY_REQ_UNIT)) {
> -				pr_err("SWReq is %d, should be at most %d\n", req_freq,
> -				       max_freq + FREQUENCY_REQ_UNIT);
> +		case MAX_GRANTED:
> +			/* Media engines have a different RP0 */
> +			if ((engine->class == VIDEO_DECODE_CLASS) ||
> +			    (engine->class == VIDEO_ENHANCEMENT_CLASS)) {
>				igt_spinner_end(&spin);
>				st_engine_heartbeat_enable(engine);
> -				err = -EINVAL;
> -				break;
> +				err = 0;
> +				continue;

I think it's preferable to move this media engine code out of the main loop
into max_granted_freq() function if possible (maybe by faking max_act_freq
if needed)?

>			}
>
> -			act_freq =  intel_rps_read_actual_frequency(rps);
> -			if (act_freq > max_act_freq)
> -				max_act_freq = act_freq;
> -
> -			st_engine_heartbeat_enable(engine);
> -			igt_spinner_end(&spin);
> -
> -			if (err)
> -				break;
> +			err = max_granted_freq(slpc, rps, &max_act_freq);
> +			break;
>		}
>
>		pr_info("Max actual frequency for %s was %d\n",
> @@ -277,31 +242,59 @@ static int live_slpc_clamp_max(void *arg)
>			err = -EINVAL;
>		}
>
> -		if (igt_flush_test(gt->i915)) {
> -			err = -EIO;
> -			break;
> -		}
> +		igt_spinner_end(&spin);
> +		st_engine_heartbeat_enable(engine);
>
>		if (err)
>			break;
>	}
>
> -	/* Restore min/max freq */
> +	/* Restore min/max frequencies */
>	slpc_set_max_freq(slpc, slpc_max_freq);
>	slpc_set_min_freq(slpc, slpc_min_freq);

As mentioned above maybe we should restore at the beginning of the test too
(before the for_each_engine() loop) to start from a known state?

Anyway here maybe get rid of the variables and:

        slpc_set_max_freq(slpc, slpc->rp0_freq);
        slpc_set_min_freq(slpc, slpc->min_freq);

Thanks.
--
Ashutosh
